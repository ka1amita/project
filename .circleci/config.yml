version: 2.1

orbs:
  gradle: circleci/gradle@3.0.0
  node: circleci/node@5.1.0
  aws-s3: circleci/aws-s3@4.0.0
  aws-cli: circleci/aws-cli@4.0
#  discord: teka23/discord@0.0.1
  discord: tkyshm/discord-orb@0.0.8

jobs:
  build_frontend:
    working_directory: &frontend ~/project/frontend
    executor:
      name: node/default
    parameters:
      env:
        description: Environment name suffix ("dev", "staging", "production") you want to deploy.
        type: enum
        enum: [ "dev", "staging", "production" ]
        default: "dev"
    steps:
      - checkout:
          path: ..
      - node/install-packages: # TODO compare with node/install from node/install-packages
          include-branch-in-cache-key: false
      - aws-cli/setup
      - aws-s3/copy:
          from: s3://committed-todo-app/envs/.env.ec2
          to: .
#      - run:
#          name: Export the actual EC2_HOST domain EC2_IP_{env}:8080/; note the `/` at the end!
#          command: |
#            set -a && source <(grep -v ^# .env.ec2) && set +a
#            echo export REACT_APP_API_URL=http://localhost:8080/ >> $BASH_ENV
#            echo export EC2_HOST=$(circleci env subst "$EC2_DOMAIN_<<parameters.env>>") >> $BASH_ENV
      - run: 
          name: Export VARs and Build
          command: |
            set -a && source <(grep -v ^# .env.ec2) && set +a
            export REACT_APP_API_URL=http://$EC2_IP_<<parameters.env>>:8080/
            echo REACT_APP_API_URL=$REACT_APP_API_URL
            npm run build
            mv -v build html
      - persist_to_workspace:
          root: .
          paths:
            - html
  
  parallel_tests_backend:
    working_directory: &backend ~/project/backend
    executor: &java8
      name: gradle/default
      tag: "8.0"
    parallelism: 5
    steps:
      - checkout:
          path: ..
      - gradle/with_cache:
          steps:
            # allows "re-run failed tests"; https://circleci.com/docs/rerun-failed-tests/
            - run:
                name: Parse classnames and split by timing
                command: |
                  cd src/test/java
                  circleci tests glob "**/*.java" | cut -c 1- | sed 's@/@.@g' | sed 's/.\{5\}$//' | circleci tests run --command=">classnames.txt xargs echo" --verbose --split-by=timings --timings-type=classname
                  [ -s classnames.txt ] || circleci-agent step halt
            - run:
                name: Run split tests
                command: |
                  GRADLE_ARGS=$(cat src/test/java/classnames.txt | awk '{for (i=1; i<=NF; i++) print "--tests",$i}')
                  echo "Prepared arguments for Gradle: $GRADLE_ARGS"
                  ./gradlew test $GRADLE_ARGS
      - store_test_results:
          path: build/test-results/test
      - store_artifacts:
          path: build/reports/tests

  build_backend:
    working_directory: *backend
    executor:
      <<: *java8
    steps:
      - checkout: # it has to be the first step in this job otherwise doesn't work later
          path: ..
      - gradle/with_cache:
          steps:
            - run:
                name: Build the jar
                command: ./gradlew bootJar

      - run:
          name: Rename buld/ to api/
          command: mv -v build/libs api
      - persist_to_workspace:
          root: .
          paths:
            - api

  deploy_backend_and_frontend:
    executor: aws-cli/default
    parameters:
      env:
        description: Environment name suffix ("dev", "staging", "production") you want to deploy.
        type: enum
        enum: ["dev", "staging", "production"]
        default: "dev"
      archive:
        description: Is it desired to archive old application build in S3 bucket?
        type: boolean
        default: false
      filename_tag:
        description: Custom build files (.jar and .env) name.
        type: string
        default: ""
    environment:
      BUCKET: s3://committed-todo-app-<<parameters.env>>
    steps:
      - aws-cli/setup
      - aws-s3/copy:
          from: s3://committed-todo-app/envs/.env.ec2
          to: .
      - run:
          name: Export the actual EC2_IP_{env}
          command: |
            set -a && source <(grep -v ^# .env.ec2) && set +a && echo export EC2_IP=$(circleci env subst "$EC2_IP_<<parameters.env>>") >> $BASH_ENV
            echo export EC2_HOST=$(circleci env subst "$EC2_DOMAIN_<<parameters.env>>")/ >> $BASH_ENV
            echo export EC2_USER=$EC2_USER >> $BASH_ENV
      - run:
          name: Check the SSH VARs
          command: echo "ssh -o StrictHostKeychecking=no ${EC2_USER}@${EC2_IP}"
      - run:
          name: SSH Connection check
          command: ssh -o StrictHostKeychecking=no ${EC2_USER}@${EC2_IP} echo Hello ${CIRCLE_USERNAME}
      - attach_workspace:
          at: build
      - run:
          name: Rename the jar to todo-app-{env}-{commit-hash}.jar
          command: mv -v $(find build/api -type f -name "*.jar") build/api/todo-app-<<parameters.env>><<parameters.filename_tag>>.jar
      - when:
          condition:
            equal: [true, <<parameters.archive>>]
          steps:
            - aws-s3/sync: # Archive old jar from S3
                from: ${BUCKET}/build
                to: ${BUCKET}/old-builds
      - aws-s3/sync: # Replace the old jar and delete .env inside the S3
          arguments: --delete
          from: build
          to: ${BUCKET}/build
      - aws-s3/copy: # Copy .env.{env} to the S3
          from: s3://committed-todo-app/envs/.env.<<parameters.env>>
          to: ${BUCKET}/build/.env.<<parameters.env>>-<<pipeline.git.revision>>
      - run:
          name: Check the build files in S3
          command: aws s3 ls --recursive ${BUCKET}/build
      - run:
          name: Kill previous java instance
          command: ssh ${EC2_USER}@${EC2_IP} "cat app.pid | xargs kill" || true # suppress error message if no processes are matched (e.g. after a crash)
     # - run:
     #     name: Kill previous nginx instance
     #     command: ssh ${EC2_USER}@${EC2_IP} "cat /run/nginx.pid | xargs sudo kill"|| true # suppress error message if no processes are matched (e.g. after a crash)
      - run:
          name: Sync the build files from S3 to EC2
          command: ssh ${EC2_USER}@${EC2_IP} "aws s3 sync --delete ${BUCKET}/build build"
      - run:
          name: Check the build files in EC2
          command: ssh ${EC2_USER}@${EC2_IP} 'ls -laF build'
      - run: 
          name: Copy frontend to default directory
          command: ssh ${EC2_USER}@${EC2_IP} "sudo rm -rfv /var/www/html && sudo mv -vf ~/build/html /var/www"
      - run:
          name: Restart nginx
          command: ssh ${EC2_USER}@${EC2_IP} "sudo nginx -s reload"
      - run:
          name: Set VARs and execute the jar
          command: ssh ${EC2_USER}@${EC2_IP} "set -a && source <(grep -v ^# build/.env.*) && set +a && export EC2_HOST=$EC2_HOST && env && echo \${$} > app.pid && exec java -jar build/api/*.jar" & sleep 20
      - run:
          name: Check running java instance
          command: ssh ${EC2_USER}@${EC2_IP} "cat app.pid | xargs ps"
      - run:
          name: Check running nginx instance
          command: ssh ${EC2_USER}@${EC2_IP} "cat /run/nginx.pid | xargs ps"
      - discord/notify:
          success_message: ":tada: Hurray, **${CIRCLE_BUILD_URL}** pipeline has succeeded! Check it here: http://$EC2_HOST"
          failure_message: ":red_circle: We have to repair it :-( You can login using this: `ssh ${EC2_USER}@${EC2_IP}`"
#      - discord/status:
#          webhook: ${DISCORD_WEBHOOK_URL}
#          success_mentions: "&1163035305545306162"
#          success_message: ":tada: Hurray, **${CIRCLE_USERNAME}**'s **${CIRCLE_JOB}** job of **${CIRCLE_PROJECT_REPONAME}** project has succeeded! Check this URL: http://$EC2_HOST"
#          failure_mentions: "1074798048611414026"
#          failure_message: ":red_circle: We have to repair it :-( You can login using this: `ssh ${EC2_USER}@${EC2_IP}`"

workflows:
  test_and_deploy_to_dev:
    when:
      not:
        or:
          - equal: [ develop, << pipeline.git.branch >> ]
          - equal: [ main, << pipeline.git.branch >> ]
    jobs:
      # - gradle/run: &build_backend
      #     name: build_backend
      #     executor:
      #       <<: *java8
      #     app_src_directory: backend
      #     command: build -x test -x checkstyleMain -x checkstyleTest -x jacocoTestCoverageVerification
      - build_backend

      - build_frontend
#      - parallel_tests_backend:
#          requires:
#            - build_backend
#      - gradle/test:
#          name: checkstyle
#          requires:
#            - build_backend
#          executor:
#            <<: *java8
#          app_src_directory: backend
#          test_command: checkstyleMain; ./gradlew checkstyleTest
#          reports_path: backend/build/reports/checkstyle
#      - gradle/test:
#          name: coverage
#          requires:
#            - build_backend
#          executor:
#            <<: *java8
#          test_command: jacocoTestReport && ./gradlew jacocoTestCoverageVerification
#          app_src_directory: backend
#          reports_path: backend/build/jacoco
      - deploy_backend_and_frontend:
          name: deploy to development environment
          requires:
            - build_backend # TODO replace with `test`
            - build_frontend
          filters:
            branches:
              ignore:
                - develop
                - main
          filename_tag: -<<pipeline.git.revision>>
          archive: false

  deploy_to_staging:
    when:
      equal: [ develop, << pipeline.git.branch >> ]
    jobs:
      - build_backend
      - build_frontend:
          env: &staging_environment staging
      - deploy_backend_and_frontend:
          name: deploy to staging environment
          requires:
            - build_backend
            - build_frontend
          env: *staging_environment

  deploy_to_production:
    when:
      equal: [ main, << pipeline.git.branch >> ]
    jobs:
      - build_backend
      - build_frontend:
          env: &production_environment production
      - deploy_backend_and_frontend:
          name: deploy to staging environment
          requires:
            - build_backend
            - build_frontend
          env: *production_environment

